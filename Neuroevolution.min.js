let Neuroevolution = function (options) {
  let self = this
  let MATH = Math
  self.options = {
    activation: function (a) {
      ap = (-a)/1
      return (1/(1 + MATH.exp(ap)))
    },
    randomClamped: function () {  // Returns a random value between -1 and 1.
      return MATH.random() * 2 - 1
    },
    network: [1, [1], 1],    // Perceptron network structure (1 hidden layer)
    population: 50,          // Population by generation
    elitism: 0.2,            // Best networks kepts unchanged for the next generation (rate)
    randomBehaviour: 0.2,    // New random networks for the next generation (rate)
    mutationRate: 0.1,       // Mutation rate on the weights of synapses
    mutationRange: 0.5,      // Interval of the mutation changes on the synapse weight
    historic: 0,             // Latest generations saved
    lowHistoric: false,      // Only save score (not the network)
    scoreSort: -1,           // Sort order (-1 = desc, 1 = asc)
    nbChild: 1               // Number of children by breeding
  }
  self.set = function (options) {  // Override default options
    for (let i in options) {
      if (this.options[i] != undefined) { // Only override if the passed in value is actually defined.
        self.options[i] = options[i]
      }
    }
  }
  self.set(options)  // Overriding default options with the pass in options

  /* NEURON **********************************************************************/
  let Neuron = function () {
    this.value = 0
    this.weights = []
  }
  Neuron.prototype.populate = function (nb) {  // Initialize number of neuron weights to random clamped values.
    this.weights = [];
    for (let i = 0; i < nb; i++) {
      this.weights.push(self.options.randomClamped());
    }
  }

  /* LAYER ***********************************************************************/
  let Layer = function (index) {  // Neural Network Layer class
    this.id = index || 0;
    this.neurons = [];
  }
  Layer.prototype.populate = function (nbNeurons, nbInputs) {  // Populate the Layer with a set of randomly weighted Neurons
    this.neurons = [];
    for (let i = 0; i < nbNeurons; i++) {
      let n = new Neuron();
      n.populate(nbInputs);
      this.neurons.push(n);
    }
  }

  /* NEURAL NETWORK **************************************************************/
  let Network = function () {
    this.layers = [];
  }
  Network.prototype.perceptronGeneration = function (input, hiddens, output) {  // Generate the Network layers
    let index = 0
    let previousNeurons = 0
    let layer = new Layer(index)
    layer.populate(input, previousNeurons) // Number of Inputs will be set to 0 since it is an input layer.
    previousNeurons = input  // number of input is size of previous layer.
    this.layers.push(layer)
    index++
    for (let i in hiddens) { // Repeat same process as first layer for each hidden layer.
      let layer = new Layer(index)
      layer.populate(hiddens[i], previousNeurons)
      previousNeurons = hiddens[i]
      this.layers.push(layer)
      index++
    }
    layer = new Layer(index)
    layer.populate(output, previousNeurons) // Number of input is equal to the size of the last hidden layer
    this.layers.push(layer)
  }
  Network.prototype.getSave = function () {  // Create a copy of the Network (neurons and weights). Returns number of neurons per layer and a flat array of all weights
    let datas = {
      neurons:[], // Number of Neurons per layer.
      weights:[]  // Weights of each Neuron's inputs.
    }
    for (let i in this.layers) {
      datas.neurons.push(this.layers[i].neurons.length)
      for (let j in this.layers[i].neurons) {
        for (let k in this.layers[i].neurons[j].weights) { // push all input weights of each Neuron of each Layer into a flat array.
          datas.weights.push(this.layers[i].neurons[j].weights[k])
        }
      }
    }
    return datas;
  }
  Network.prototype.setSave = function (save) {  // Apply network data (neurons and weights)
    let previousNeurons = 0
    let index = 0
    let indexWeights = 0
    this.layers = []
    for (let i in save.neurons) {
      // Create and populate layers
      let layer = new Layer(index)
      layer.populate(save.neurons[i], previousNeurons)
      for (let j in layer.neurons) {
        for (let k in layer.neurons[j].weights) {
          layer.neurons[j].weights[k] = save.weights[indexWeights];
          indexWeights++
        }
      }
      previousNeurons = save.neurons[i]
      index++
      this.layers.push(layer)
    }
  }
  Network.prototype.3 = function (inputs) {  // Compute the output of an input
    // Set the value of each Neuron in the input layer.
    for (let i in inputs) {
      if (this.layers[0] && this.layers[0].neurons[i]) {
        this.layers[0].neurons[i].value = inputs[i]
      }
    }

    let prevLayer = this.layers[0] // Previous layer is input layer.
    for (let i = 1, l = this.layers.length; i < l; i++) {
      for (let j in this.layers[i].neurons) { // For each Neuron in each layer.
        let sum = 0;
        for (let k in prevLayer.neurons) { // Every Neuron in the previous layer is an input to each Neuron in the next layer.
          sum += prevLayer.neurons[k].value * this.layers[i].neurons[j].weights[k]
        }
        this.layers[i].neurons[j].value = self.options.activation(sum)  // Compute the activation of the Neuron
      }
      prevLayer = this.layers[i]
    }

    let out = []
    let lastLayer = this.layers[this.layers.length - 1]
    for (let i in lastLayer.neurons) {
      out.push(lastLayer.neurons[i].value)
    }
    return out  // All outputs of the Network
  }

  /* GENOME **********************************************************************/
  let Genome = function (score, network) {
    this.score = score || 0;
    this.network = network || null;
  }

  /* GENERATION ******************************************************************/
  let Generation = function () {
    this.genomes = [];
  }
  Generation.prototype.addGenome = function (genome) {
    for (var i = 0; i < this.genomes.length; i++) {  // Locate position to insert Genome into. The gnomes should remain sorted
      if (self.options.scoreSort < 0) {  // Sort in descending order.
        if (genome.score > this.genomes[i].score) {
          break
        }
      } else {  // Sort in ascending order.
        if (genome.score < this.genomes[i].score) {
          break
        }
      }
    }
    this.genomes.splice(i, 0, genome)  // Insert genome into correct position
  }
  Generation.prototype.breed = function (g1, g2, nbChilds) {  // Breed to genomes to produce offspring(s)
    let datas = []
    for (let nb = 0; nb < nbChilds; nb++) {
      let data = JSON.parse(JSON.stringify(g1))
      for (let i in g2.network.weights) {
        if (MATH.random() <= 0.5) {
          data.network.weights[i] = g2.network.weights[i]
        }
      }
      for (let i in data.network.weights) {  // Perform mutation on some weights
        if (MATH.random() <= self.options.mutationRate) {
          data.network.weights[i] += MATH.random() * self.options.mutationRange * 2 - self.options.mutationRange
        }
      }
      datas.push(data)
    }
    return datas
  }
  Generation.prototype.generateNextGeneration = function () {
    let nexts = []
    for (let i = 0, t = MATH.round(self.options.elitism * self.options.population); i < t; i++) {
      if (nexts.length < self.options.population) {
        nexts.push(JSON.parse(JSON.stringify(this.genomes[i].network)))
      }
    }
    for (let i = 0, t = MATH.round(self.options.randomBehaviour * self.options.population);  i < t; i++) {
      let n = JSON.parse(JSON.stringify(this.genomes[0].network))
      for (let k in n.weights) {
        n.weights[k] = self.options.randomClamped()
      }
      if (nexts.length < self.options.population) {
        nexts.push(n)
      }
    }
    let max = 0;
    while(true) {
      for (let i = 0; i < max; i++) {
        // Create the children and push them to the nexts array.
        let childs = this.breed(this.genomes[i], this.genomes[max], (self.options.nbChild > 0 ? self.options.nbChild : 1) )
        for (let c in childs) {
          nexts.push(childs[c].network);
          if (nexts.length >= self.options.population) {
            // Return once number of children is equal to the population by generation value
            return nexts
          }
        }
      }
      max++
      if (max >= this.genomes.length - 1) {
        max = 0
      }
    }
  }

  /* GENERATIONS *****************************************************************/
  let Generations = function () {  // Hold's previous Generations and current Generation
    this.generations = []
    let currentGeneration = new Generation()
  }
  Generations.prototype.firstGeneration = function () {
    let out = []
    for (let i = 0, t = self.options.population; i < t; i++) {
      let nn = new Network()  // Generate the Network and save it
      nn.perceptronGeneration(self.options.network[0], self.options.network[1], self.options.network[2])
      out.push(nn.getSave())
    }
    this.generations.push(new Generation())
    return out
  }
  Generations.prototype.nextGeneration = function () {
    if (this.generations.length === 0) { // Need to create first generation
      return false
    }
    let gen = this.generations[this.generations.length - 1].generateNextGeneration()
    this.generations.push(new Generation())
    return gen
  }
  Generations.prototype.addGenome = function (genome) {
    if (this.generations.length === 0) return false
    return this.generations[this.generations.length - 1].addGenome(genome)
  }

  /* SELF ************************************************************************/
  self.generations = new Generations()
  self.restart = function () {
    self.generations = new Generations()
  }
  self.nextGeneration = function () {
    let networks = []
    if (self.generations.generations.length === 0) {
      networks = self.generations.firstGeneration()
    } else {
      networks = self.generations.nextGeneration()
    }
    let nns = []
    for (let i in networks) {
      let nn = new Network()
      nn.setSave(networks[i])
      nns.push(nn)
    }
    if (self.options.lowHistoric) {  // Remove old Networks
      if (self.generations.generations.length >= 2) {
        let genomes = self.generations .generations[self.generations.generations.length - 2].genomes
        for (let i in genomes) {
          delete genomes[i].network
        }
      }
    }
    if (self.options.historic != -1) {  // Remove older generations
      if (self.generations.generations.length > self.options.historic + 1) {
        self.generations.generations.splice(0, self.generations.generations.length - (self.options.historic + 1))
      }
    }
    return nns
  }
  self.networkScore = function (network, score) {  // viene chiamato quando un network (bird) muore per aggiornare il suo punteggio finale
    self.generations.addGenome(new Genome(score, network.getSave()))
  }
}
